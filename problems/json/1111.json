{
    "number": "1111",
    "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
    "url": "https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings",
    "difficulty": "Medium",
    "question": "A string is a valid parentheses string&#xA0;(denoted VPS) if and only if it consists of &quot;(&quot; and &quot;)&quot; characters only, and:\n\n\n\tIt is the empty string, or\n\tIt can be written as&#xA0;AB&#xA0;(A&#xA0;concatenated with&#xA0;B), where&#xA0;A&#xA0;and&#xA0;B&#xA0;are VPS&apos;s, or\n\tIt can be written as&#xA0;(A), where&#xA0;A&#xA0;is a VPS.\n\n\nWe can&#xA0;similarly define the nesting depth depth(S) of any VPS S as follows:\n\n\n\tdepth(&quot;&quot;) = 0\n\tdepth(A + B) = max(depth(A), depth(B)), where A and B are VPS&apos;s\n\tdepth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A), where A is a VPS.\n\n\nFor example,&#xA0; &quot;&quot;,&#xA0;&quot;()()&quot;, and&#xA0;&quot;()(()())&quot;&#xA0;are VPS&apos;s (with nesting depths 0, 1, and 2), and &quot;)(&quot; and &quot;(()&quot; are not VPS&apos;s.\n\n&#xA0;\n\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that&#xA0;A and B are VPS&apos;s (and&#xA0;A.length + B.length = seq.length).\n\nNow choose any such A and B such that&#xA0;max(depth(A), depth(B)) is the minimum possible value.\n\nReturn an answer array (of length seq.length) that encodes such a&#xA0;choice of A and B:&#xA0; answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.&#xA0; Note that even though multiple answers may exist, you may return any of them.\n\n&#xA0;\nExample 1:\n\nInput: seq = &quot;(()())&quot;\nOutput: [0,1,1,1,1,0]\n\n\nExample 2:\n\nInput: seq = &quot;()(())()&quot;\nOutput: [0,0,0,1,1,0,1,1]\n\n\n&#xA0;\nConstraints:\n\n\n\t1 &lt;= seq.size &lt;= 10000\n\n",
    "code": "undefinedpublic class Solution {    public int[] MaxDepthAfterSplit(string seq) {            }}"
}